name: Uptime Monitor

on:
  schedule:
    # Run every 30 minutes
    - cron: "*/30 * * * *"
  workflow_dispatch: # Allows manual run button

jobs:
  check-server:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to save history.json
      
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Check Server Status (Node.js Pro)
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // CONFIGURATION
            const URL = "https://ztext-cloudbox.serveousercontent.com";
            
            console.log(`Pinging: ${URL}`);
            
            try {
              // 1. Perform Request with Browser-like Headers
              const response = await fetch(URL, {
                method: 'GET',
                headers: {
                  // Crucial: Serveo blocks empty User-Agents. We look like Chrome.
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                  'Accept': 'application/json, text/html, */*'
                },
                redirect: 'follow', // Automatically follow HTTP -> HTTPS
                signal: AbortSignal.timeout(10000) // 10s Timeout
              });

              console.log(`Response Code: ${response.status} (${response.statusText})`);

              // 2. Determine Status (Accept 200-299 as UP)
              if (response.ok) {
                console.log("RESULT: UP");
                core.setOutput('status', 'up');
              } else {
                console.log("RESULT: DOWN");
                core.setOutput('status', 'down');
                
                // 3. Debug: Print the first 200 chars of the error page to see WHY
                const text = await response.text();
                console.log(`Server Reply: ${text.substring(0, 200)}...`);
              }

            } catch (error) {
              console.log(`FATAL ERROR: ${error.message}`);
              core.setOutput('status', 'down');
            }

      - name: Update History Log
        run: |
          # Read status from the Node script output
          STATUS="${{ steps.check.outputs.status }}"
          TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          # Create temporary file with new entry
          echo "{\"time\": \"$TIME\", \"status\": \"$STATUS\"}" > new_entry.json
          
          # Ensure history.json exists
          if [ ! -f history.json ]; then echo "[]" > history.json; fi
          
          # Merge using jq (Appends new entry, keeps last 100)
          jq --slurpfile new new_entry.json '. + $new | .[-100:]' history.json > history_temp.json
          mv history_temp.json history.json

      - name: Commit and Push
        run: |
          git config --global user.name "Z-Text Bot"
          git config --global user.email "bot@ztext.app"
          
          # Stash local changes, pull remote to avoid conflicts
          git pull --rebase --autostash
          
          git add history.json
          git commit -m "Update status log: ${{ steps.check.outputs.status }}" || exit 0
          git push